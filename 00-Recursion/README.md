# Recursion
(순환, 재귀)
참고: [realpython.com > python-recursion](https://realpython.com/python-recursion)

 프로그래밍에서 재귀(Recursion)란 어떤 함수 내에서 자기 자신을 호출하는 것을 말한다. 이런 함수를 재귀 함수라고 하는데, 거의 대부분의 문제들은 재귀적 방법이 아니더라도 해결이 가능하지만, Tree 처럼 중첩 구조의 순회 알고리즘을 구현하는 경우 재귀적으로 구현 한다면 코드가 더 간결하고 명확해질 수 있다.
  때로 재귀적인 연산으로 인해 지나치게 많은 메모리를 사용하게 되거나 연산 속도가 더 느릴 수 있으니 주의.

code:
```python
// recursion example
// print countdown from n to 0
def countdown(n):
    if n > 0:
        print(n)
        countdown(n-1)
```

result:
```python
>>> countdown(5)
5
4
3
2
1
```

재귀 함수를 호출하는 조건이 없다면 무한히 호출될 수 있는데, Python 의 재귀 중첩 수의 제한은 sys module 의 getrecursionlimit() 함수를 호출하여 확인하고 setrecursionlimit() 함수로 설정할 수 있다.(기본값은 1000)

```python
>>> from sys import getrecursionlimit, setrecursionlimit
>>> getrecursionlimit()
1000
>>> setrecursionlimit(2000)
>>> getrecursionlimit()
2000
```


## factorial
자연수의 계승, `!` 기호를 사용한다.

```
n! = 1 * 2 * 3 * ... * n
```

factorial 은 다음과 같이 정의할 수 있다.
```
n! : n == 0 OR n == 1 -> return 1
     n > 1 -> return n * (n-1)!
```

구현: [factorial.py](https://github.com/pacho-h/data-structure-in-python/blob/main/0-Recursion/factorial.py)


## exponentiation
거듭제곱
정수부(base)와 지수부(exponent)로 구분된다.
```
2^8 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 = 256
2의 8승이라고도 하며, 2를 8번 곱한다.
```

구현: [exponentiation.py](https://github.com/pacho-h/data-structure-in-python/blob/main/0-Recursion/exponentiation.py)


## Fibonacci numbers
피보나치 수
0번째 항이 0, 1번째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열이다.
```
피보나치 수 F
F[0] = 0
F[1] = 1
F[n] = F[n - 2] + F[n - 1]  # (if n > 2)
```

구현: [fibonacci_numbers.py](https://github.com/pacho-h/data-structure-in-python/blob/main/0-Recursion/fibonacci_numbers.py)


## Tower of Hanoi
하노이의 탑은 프랑스의 수학자인 에두아르 뤼카(Édouard Lucas)가 클라우스 교수(professeur N. Claus)라는 필명으로 1883년에 발표하였다. 1년 후 드 파르빌(Henri de Parville)은 Claus가 Lucas의 애너그램임을 밝히면서 다음과 같은 이야기로 하노이의 탑을 소개하였다.
>"인도 베나레스에 있는 한 사원에는 세상의 중심을 나타내는 큰 돔이 있고 그 안에 세 개의 다이아몬드 바늘이 동판 위에 세워져 있습니다. 바늘의 높이는 1 큐빗이고 굵기는 벌의 몸통만 합니다. 바늘 가운데 하나에는 신이 64개의 순금 원판을 끼워 놓았습니다. 가장 큰 원판이 바닥에 놓여 있고, 나머지 원판들이 점점 작아지며 꼭대기까지 쌓아 있습니다. 이것은 신성한 브라흐마의 탑입니다. 브라흐마의 지시에 따라 승려들은 모든 원판을 다른 바늘로 옮기기 위해 밤낮 없이 차례로 제단에 올라 규칙에 따라 원판을 하나씩 옮깁니다. 이 일이 끝날 때, 탑은 무너지고 세상은 종말을 맞이하게 됩니다."

이후 라우즈 볼, 가드너 등이 하노이의 탑을 소개하면서 널리 알려졌다.

출처: [위키피디아](https://ko.wikipedia.org/wiki/%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98_%ED%83%91)
*큐빗: 성인 남자의 팔꿈치부터 가운데 손가락 끝까지의 길이로 약 50cm
*베나레스(Benares): 현재의 바라나시(Varanasi). 갠지스강이 흐르는 힌두교의 성지로 유명하다.

(물론 전설일 뿐이고 하노이의 탑은 실존하지 않는다고 한다.)

### 목표: 아래 규칙을 지키며 어느 하나의 다이아몬드 바늘에 있는 동판들을 다른 하나의 다이아몬드 바늘로 옮기는 것.

- 한 번에 한개의 원판만 옮길 수 있다.
- 가장 위에 있는 원판만 이동할 수 있다.
- 큰 원판이 작은 원판 위에 있어서는 안 된다.

3개의 바늘을 각각 A, B, C라 이름을 붙이고, 동판들은 크기가 작은 것부터 차례로 1~n번까지 번호를 붙였다.
바늘 A에 있는 동판들을 바늘 B로 옮기는 과정을 동판 개수 별로 한 동작 씩 풀어보면,

```
1개:
  1. 동판1을 A에서 B로 옮긴다. (동판1 이동 완료)

2개:
  1. 처음에 동판1을 A에서 B로 옮기면, 동판2는 동판1 위에 올라갈 수 없기 때문에 일단 동판1을 C로 옮겨둔다.
  2. 동판2를 B로 옮긴다.(동판2 이동 완료)
  3. C에 있는 동판1을 B에 있는 동판2 위로 옮긴다. (동판1 이동 완료)
3개:
  1. 처음에 동판1을 A에서 B로 옮긴다.
  2. 동판2를 C로 옮긴다.
  3. B에 있는 동판1을 C에 있는 동판2 위로 옮긴다.
  4. A에 있는 동판3을 B로 옮긴다. (동판3 이동 완료)
  5. C에 있는 동판1을 A로 옮긴다.
  6. C에 있는 동판2를 B로 옮긴다. (동판2 이동 완료)
  7. A에 있는 동판1을 B로 옮긴다. (동판1 이동 완료)
...
```

이렇게 한 동작 씩 풀어서 보니 동판을 현위치에서 목표 위치로 옮긴다는 공통된 작업을 반복하는데, 2개 이상의 동판을 옮기는 경우 반드시 출발지, 목적지 외의 추가의 보조 바늘(경유지)이 필요함을 알 수 있다.

### 어떤 규칙성이…?

 동판이 2개인 경우 동판2를 B(목적지)로 옮기기 위해 동판1을 C(경유지)로 잠시 옮겨둔채 동판2를 이동 했다. 따라서 동판1은 실제로 A(출발지) → C(경유지) → B(목적지)로 이동 시킨다. 이 전체 동작은 동판 1개를 움직이는 3가지 동작으로 볼 수 있다.

- 1번 동작은 동판1을 A(출발지)에서 C(경유지)로 옮기는 동작
- 2번 동작은 동판2를 B(도착지)로 옮기고 더 이상 움직이지 않는 완료 동작.
- 3번 동작은 동판1을 C(경유지)에서 B(도착지)로 옮기고 더 이상 움직이지 않는 완료 동작.

 동판이 3개인 경우 가장 큰 동판3을 B(목적지)로 옮기기 위해선 동판1, 2를 잠시 C(경유지)로 옮겨두어야한다. 위에서 나열한 동작들을 보니 

- 1번~3번 동작은 동판1, 2를 A(출발지)에서 C(경유지)로 옮기는 동작으로 묶을 수 있다.
- 4번 동작은 동판3을 목적지로 옮기고 더 이상 움직이지 않는 완료 동작.
- 5번~7번 동작은 동판1, 2를 C(경유지)에서 B(도착지)로 옮기는 완료 동작으로 묶을 수 있다.

  이렇게 풀어서 보니 가장 아래에 있는 원판은 단 한 번에 목적지로 이동할 수 있고, 가장 큰 원판 위에 있는 원판 묶음은 반드시 경유지를 한 번 거쳐서 목적지로 이동할 수 있다.

  가장 큰 원판을 제외한 원판묶음이 경유지에서 목적지로 이동하는 상황을 보면, 경유지가 출발지가 되고, 출발지가 경유지가 될뿐 전체 원판 중 가장 큰 원판 하나를 제외한 나머지 원판들(n-1개)이 경유지에서 목적지로 이동하는 또하나의 문제로 볼 수 있다.

처음에 나열한 동작들에 설명을 덧붙이면,

```
3개:
--- 동판 2개를 A에서 C로 옮기는 문제 (A:출발지/B:경유지/C:도착지)
  1. 처음에 동판1을 A에서 B로 옮긴다.
  2. 동판2를 C로 옮긴다.
  3. B에 있는 동판1을 C에 있는 동판2 위로 옮긴다.
---
--- 동판 1개를 A에서 B로 옮기는 문제(A:출발지/B:도착지/C:경유지(이지만 필요없음))
  4. A에 있는 동판3을 B로 옮긴다. (동판3 이동 완료)
---
--- 동판 2개를 C에서 B로 옮기는 문제(A:경유지/B:도착지/C:출발지)
  5. C에 있는 동판1을 A로 옮긴다.
  6. C에 있는 동판2를 B로 옮긴다. (동판2 이동 완료)
  7. A에 있는 동판1을 B로 옮긴다. (동판1 이동 완료)
--- 
```

  이렇게 동일한 동작을 출발지, 경유지만 바꿔가며 반복해야하는 문제로 재귀 함수를 활용하면 쉽게 풀어낼 수 있다.

그리고 원판이 n개일 때 최소 이동 횟수는 2^n-1회이다.

### 구현

  이를 pseudo code로 써보면..

```
// 원판의 번호는 1 ~ n
function 이동(원판_번호, 출발지, 목적지)
  "{원판_번호}번 원판 이동 {출발지} -> {목적지}"

function 원판들_옮기기(원판의_수, 출발지, 목적지, 경유지)
  if 원판의_수 == 1 then
    이동(1, 출발지, 목적지)
  else if 원판의_수 > 1 then
    원판들_옮기기(원판의_수, 출발지, 경유지, 목적지)
    이동(원판의_수, 출발지, 목적지)
    원판들 옮기기(원판의_수, 경유지, 목적지, 출발지)
  endif
```
구현: [tower_of_hanoi.py](https://github.com/pacho-h/data-structure-in-python/blob/main/0-Recursion/tower_of_hanoi.py)
